package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"fmt"
	"strconv"

	"github.com/sean-miningah/sil-backend-assessment/internal/adapters/handlers/graphql/generated"
	"github.com/sean-miningah/sil-backend-assessment/internal/adapters/handlers/graphql/model"
	"github.com/sean-miningah/sil-backend-assessment/internal/core/domain"
	"go.opentelemetry.io/otel"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProductInput) (*model.Product, error) {
	ctx, span := otel.Tracer("").Start(ctx, "GraphQL.CreateProduct")
	defer span.End()

	categoryID, err := strconv.ParseUint(input.CategoryID, 10, 32)
	if err != nil {
		return nil, err
	}

	product := &domain.Product{
		Name:       input.Name,
		Price:      input.Price,
		CategoryID: uint(categoryID),
	}

	if err := r.productService.CreateProduct(ctx, product); err != nil {
		return nil, err
	}

	category := &model.Category{
		ID: strconv.FormatUint(uint64(product.CategoryID), 10),
	}

	return &model.Product{
		ID:       strconv.FormatUint(uint64(product.ID), 10),
		Name:     product.Name,
		Price:    product.Price,
		Category: category,
	}, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input model.UpdateProductInput) (*model.Product, error) {
	ctx, span := otel.Tracer("").Start(ctx, "GraphQL.UpdateProduct")
	defer span.End()

	productID, err := strconv.ParseUint(input.ID, 10, 32)
	if err != nil {
		return nil, err
	}

	product, err := r.productService.GetProduct(ctx, uint(productID))
	if err != nil {
		return nil, err
	}

	if input.Name != nil {
		product.Name = *input.Name
	}
	if input.Price != nil {
		product.Price = *input.Price
	}
	if input.CategoryID != nil {
		categoryID, err := strconv.ParseUint(*input.CategoryID, 10, 32)
		if err != nil {
			return nil, err
		}
		product.CategoryID = uint(categoryID)
	}

	if err := r.productService.UpdateProduct(ctx, product); err != nil {
		return nil, err
	}

	category := &model.Category{
		ID: strconv.FormatUint(uint64(product.CategoryID), 10),
	}

	return &model.Product{
		ID:       strconv.FormatUint(uint64(product.ID), 10),
		Name:     product.Name,
		Price:    product.Price,
		Category: category,
	}, nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (bool, error) {
	ctx, span := otel.Tracer("").Start(ctx, "GraphQL.DeleteProduct")
	defer span.End()

	productID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return false, err
	}

	if err := r.productService.DeleteProduct(ctx, uint(productID)); err != nil {
		return false, err
	}

	return true, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	ctx, span := otel.Tracer("").Start(ctx, "GraphQL.Products")
	defer span.End()

	products, err := r.productService.ListProducts(ctx)
	if err != nil {
		return nil, err
	}

	// Convert domain products to GraphQL model
	var result []*model.Product
	for _, p := range products {
		category := &model.Category{
			ID: strconv.FormatUint(uint64(p.CategoryID), 10),
		}
		result = append(result, &model.Product{
			ID:       strconv.FormatUint(uint64(p.ID), 10),
			Name:     p.Name,
			Price:    p.Price,
			Category: category,
		})
	}

	return result, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	ctx, span := otel.Tracer("").Start(ctx, "GraphQL.Product")
	defer span.End()

	productID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, err
	}

	product, err := r.productService.GetProduct(ctx, uint(productID))
	if err != nil {
		return nil, err
	}
	category := &model.Category{
		ID: strconv.FormatUint(uint64(product.CategoryID), 10),
	}

	return &model.Product{
		ID:       strconv.FormatUint(uint64(product.ID), 10),
		Name:     product.Name,
		Price:    product.Price,
		Category: category,
	}, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	panic(fmt.Errorf("not implemented: Categories - categories"))
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id string) (*model.Category, error) {
	panic(fmt.Errorf("not implemented: Category - category"))
}

// CategoryWithChildren is the resolver for the categoryWithChildren field.
func (r *queryResolver) CategoryWithChildren(ctx context.Context, id string) (*model.Category, error) {
	panic(fmt.Errorf("not implemented: CategoryWithChildren - categoryWithChildren"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
